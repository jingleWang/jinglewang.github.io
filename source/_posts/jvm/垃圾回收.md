---
title: Java垃圾回收
date: 2018/4/16 17:48:25  # 文章发表时间
toc: true
tags:
- Java
- JVM
categories:
- JVM
- 内存管理
thumbnail: http://pic.jingl.wang/2018-08-14-151534.jpg
---


> 在Java的技术体系中的自动内存管理主要解决了2个问题即内存的分配及内存的回收，在这篇文章中，我们主要讨论的是JVM的垃圾回收机制。对于垃圾回收，我们主要需要考虑3个问题：
>
> * 哪些内存需要被回收
> * 如何回收
> * 什么时候需要被回收
>
> 接下来，我将围绕这3个问题，对Java的垃圾回收做一个简单的介绍。

<!-- more --> 

## 哪些内存需要被回收

在进行内存回收之前，我们首先需要知道，哪些对象可以被回收，需要有一定的方法去判断一个对象是否能被回收。

### 引用计数算法

引用计数算法是一个非常古老的算法，实现非常的简单，判定的效率也非常高，他的思路是在对象中添加一个引用计数器，每当有一个地方引用这个对象时，这个计数器就加1，但一个地方的引用失效时，这个计数器就减1，如果这个计数器为0，就代表这个对象没有被引用，可以被回收。

这个算法，在大部分情况下，都是一个非常不错的算法，当时在Java虚拟机中，并没有使用这个算法来管理内存，主要是因为这个算法无法解决互相循环引用的问题，如下面这段代码

```Java
A a = new A();
B b = new B();
a.b = b;
b.a = a;

a = null;
b = null;
```

当执行完第5、6行代码时，这2个对象已经不可能在被访问，当时由于他们之间存在着互相引用，这两个对象的引用计数器都不为0，所以如果使用引用计数作为判断算法，这个2个对象将不能被垃圾收集器回收。

### 可达性分析算法

在主流商用虚拟机中，都会使用一种叫可达性分析的方法来确定一个对象是否可以被回收，这种方法的主要思路是从一个`GC Root`作为起始点，开始向下进行搜索，当一个对象与GC Root之间没有引用链相连的话，就说明这个对象不可用。

![可达性测试判断对象是否可以被回收](http://pic.jingl.wang/2018-04-16-152250.png)

如上图所示，虽然Obj 6、7、8直接有相互的关联，但Obj 6与GC Root 之间没有直接的引用链进行连接，所以Obj6，Obj7, Obj8将会被判断为无效对象。

一般的，以下几种类型的对象可以被作为GC Root：

* Java栈（栈帧中的本地变量表）中的引用的对象
* 方法区中静态属性引用的对象
* 方法区中常量引用的对象
* 本地方法栈中JNI（Native 方法）引用的对象

### 4种引用类型

* 强引用： 普通的引用关系，只要一个对象有强引用存在，那么永远不会被回收。
* 软引用：当内存即将溢出时，垃圾收集器将软引用的对象纳入回收范围进行回收，如果回收后任没有足够内存，才会抛出内存溢出的异常，用SoftReference来实现
* 弱引用：被弱引用关联的对象只能存活至下一次垃圾回收之前，用WeakReference来实现
* 虚引用：最弱的一种引用关系，这种关系完全不会对其生存时间构成影响，这种引用的唯一用处就是在一个对象被回收时，收到一个系统通知。用PhantomReference来实现。



### 最后一次拯救自己的机会

一个在可达性分析中被判断需要回收的对象，在被真正回收之前，可能还要经历2次标记，第一次标记将会筛选出需要执行finallize方法的对象（既重写过finilize方法的类的实例），当对象没有覆盖finalize方法，或者已经执行过finalize方法，则会被判断为不需要执行finalize方法。

所有在第一次标记中被判断为需要执行finalize方法的对象，将会被放入一个叫F-Queue的队列中，稍后JVM会触发执行finalize方法，但并不保证会等待finalize方法执行完毕。finalize方法即是最后一次能拯救自己的机会，在finalize方法中可以将对象赋值给某个类变量。那么在稍后GC对F-Queue的第二次小规模标记时，将会把这些对象移除即将回收的集合，经过2次标记，那么这个对象基本上就会被回收了。

那些在finalize方法中存活下来的对象，如果下一次被判断为需要回收，那么将不会被执行finalize方法，直接被回收。

### 回收方法区

在方法区中，主要回收的是2部分对象：废弃常量和无用的类。废弃的常量就是在任何地方都没有被引用的对象，而无用的类的判断比较复杂需要满足3个条件：

* 该类所有的实例都已经被回收
* 加载该类的ClassLoader已经被回收
* 该类的Class对象没有被引用，在任何地方无法通过反射访问该类

当满足上面三个条件后，这个无用的类，就可以被回收了。

## 如何回收

### 垃圾收集算法

#### 标记-清除算法

标记-清除，是一种最基本的垃圾收集算法，分为标记和清除两个步骤：首先标记出那些对象可以被回收，然后在标记完成后统一进行回收操作。这种算法的有2个不足的地方：

* 效率问题：标记和清除的效率都不高
* 空间问题：会产生大量的内存碎片，导致为大对象分配内存时无法找到足够的内存空间而提前触发垃圾回收

#### 复制算法

为了解决标记清除带来的不足，出现了一种复制算法，这种方法的思路是将内存区域分为2块，每次只使用其中的一块，但这一块内存用尽，将会触发一次垃圾回收，将标记存活的对象复制到另一块内存中，然后将这一块内存一次性全部清空，运行高效，也解决了内存碎片的问题，但是，这需要将内存空间缩小为原来的一半作为代价，而且当存在大量对象存活时，就需要进行较多的复制操作，效率将会变得非常低，所以这种算法一半会用在新生代中。

现在的商业JVM一般都采用这种算法作为新生代的回收机制， 新生代的一个特点就是大多数对象会朝生夕死，所以并不需要按照1：1的比例来划分内存空间，而是可以将内存划分为一块较大的eden空间和2块较小的Survivor空间，每次使用eden和其中的一块Survivor，当回收时，将存活的对象复制到另一块Survivor中，最后清理掉Eden和刚才用过的Survivor，Hotspot虚拟机默认的Eden和Survivor的分配比是8：1，所以至少有90%的内存能被使用，只有10%的内存会被浪费。

在某些场景下，我们会遇到Survivor空间不够用的情况，这时，需要依赖其他内存（老年代）进行分配担保，如果在Survivor中没有足够的空间来容纳存活的对象，那么这些对象将会被直接放入老年代。

#### 标记整理算法

针对老年代高存活率的特点，出现了标记整理算法，其中标记过程仍然和之前是一样的，但后续的步骤是将所有存活的对象都向一端移动，然后直接清除边界以外的内存。

#### 分代收集算法

分代收集本质上是一种整合前几种算法的思想，它将内存分为新生代和老年代，然后根据不同年代的特点采用合适的收集算法。 

### HotSpot中根节点的枚举

在进行可达性分析时，我们需要非常快速的知道在全局性的属性或栈中，哪些地方是引用，可以作为GC Root，然而，这个寻找的范围是非常大的，如果需要逐个检查，那会非常的耗时，而且在枚举GC root时，必须保证一致性，也就是在分析过程中，对象的引用关系不能发生变化，这就必须要在分析过程中暂停所有线程（Stop the world）。

#### OopMap

在目前主流的JVM中使用的都是准确式GC（能够准确的知道一块内存是否为引用），在HotSpot中，使用了一个叫OopMap的结构来达到这个目的，他会记录下栈和寄存器中那些地方为引用，这样在扫描时就能快速的知道那些地方是GC root。

#### 安全点

几乎每一个操作，都将会改变OopMap, 所以如果每执行一条操作就修改一次OopMap，将会带来很多额外的开销，所以就有了安全点的概念，每当程序执行到这些安全点时，才会生成OopMap，所以也只有在执行到安全点的时候，才可以进行GC。

安全点的选择是以“是否具有让程序长时间运行的特征”作为选择依据的。比如:方法调用，循环跳转，异常跳转等。

最后一个问题是，如何在需要GC时，让所有线程都中断在安全点上，一般有2种方案：

* 抢先式中断：在GC发生时，中断所有线程，如果有线程没有在安全点上，则恢复线程，直到它运行到一个安全点。
* 主动式中断：这种方法需要设置一个用于标记是否需要GC的标志，当每个线程运行到安全点时，将会主动询问是否需要GC,但标记为真时，挂起当前线程。 

#### 安全区

当一个线程处于Sleep状态，或者Block状态时，没有被分配CPU时间，无法响应系统的中断请求，也就无法到达该线程的安全点，所以就需要用安全区来解决了。既在某个区域内，引用关系不会发生变化，在任意地方开始GC都是安全的。

## 什么时候回收

### 分配回收策略

#### 对象优先在Eden区进行分配

大多数情况下，对象会优先被分配进入Eden区，当Eden没有足够的空间来容纳新对象时，JVM会触发一次Minor GC（新生代GC），将Eden+当前Survivor中的对象复制进入另一块Survivor中，如果存活的对象大小超出Survivor区的大小，JVM将会使用分配担保机制，将对象移入老年代中。

#### 大对象直接进入老年代

当出现大对象时，往往会导致提前触发垃圾回收，以及在Eden和Survivor之间出现大量的内存复制，所以JVM提供了一个pretenureSizeThreshold参数，让超过这个大小的对象直接在老年代进行分配内存。

#### 长期存活对象进入老年代

当对象没经历一次Minor GC时，他的年龄就增加一岁，当年龄增加到一定的程度（默认15岁），该对象就会没放入老年代中。

#### 动态年龄判断

如果在Survivor中相同年龄大小的所有对象大小总和大于Survivor空间的一半，年龄大于等于该年龄的对象就可以直接进入老年代中。

#### 空间分配担保

在发生Minor GC之前，JVM会首先检查老年代中最大可用连续空间是否大于新生代所有对象之和，如果这个条件成立，那么Minor GC是安全的，如果不成立，那么将会查看HandlePromotionFailure参数是否设置为允许担保失败，如果允许，将会继续检查老年代最大连续可用空间是否大于历次晋升到老年代的对象的大小总和的平均值，如果大于，则将会触发一次Minor GC, 如果小于，或者不允许担保失败，或者Minor GC失败是，将会触发老年的的Full GC。

### Minor GC

发生在新生代的垃圾回收，非常频繁，回收速度较快

### Full GC

发生在老年代的垃圾回收，也叫Major GC, 经常会出现伴随至少一次的Minor GC， 速度比Minor GC慢十倍以上。

 