{"meta":{"title":"Ben's Blog","subtitle":null,"description":null,"author":"Mr. Ben","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"Hello World","slug":"helloworld","date":"2019-02-27T11:00:44.931Z","updated":"2019-02-27T11:00:44.931Z","comments":true,"path":"2019/02/27/helloworld/","link":"","permalink":"http://yoursite.com/2019/02/27/helloworld/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"RPC介绍","slug":"JavaMemory","date":"2018-04-14T09:48:25.000Z","updated":"2019-02-27T11:42:18.970Z","comments":true,"path":"2018/04/14/JavaMemory/","link":"","permalink":"http://yoursite.com/2018/04/14/JavaMemory/","excerpt":"","text":"Java内存区域 对于从事C、C++的开发人员来说，在内存管理方面他们对于每一个对象都拥有所有权，需要负责每一个对象的创建与销毁。对于从事Java的开发人员来说，由于有垃圾回收机制的存在，可以不用对对象的内存管理负责，但一旦出现内存泄漏，如果不了解虚拟机的内存机制，对于开发人员来说查找错误是非常困难的。 [TOC] 运行时数据区域 在Jvm规范中，规定了上图所示的几个数据区域，有些是所有线程都共享的，有些则是线程隔离的。 程序计数器​ 程序计数器可以看做当前所执行字节码指令的行号指示器。由于，JVM需要在切换线程之后，恢复至正确的执行位置，所以每一个线程都需要一个程序计数器来记录当前执行位置，且各个线程直接互不影响。 ​ 程序计数器只存储当前执行字节码指令的地址，所以这是一个固定的大小，所以程序计数器也是JVM规范中唯一个没有 OutOfMemoryError 的区域。当JVM所执行的是Native方式时，这个计数器为空。 Java栈​ Java栈也是一个线程私有的内存区域，他描述了Java方法执行的内存模型，在每个方法执行的同时，会新建一个栈帧，用于存储局部变量表，方法出口等信息。当一个方法执行完毕，就会有一个栈帧出栈。 ​ 局部变量表存放着编译期可知的所有基本类型的变量、对象引用和返回值类型。其中，64位长度的long和double需要占用2个局部变量空间，其余类型只需要占用一个。局部变量表所需要的空间，在编译期就已经完成分配，执行这个方法需要在帧中分配多少空间是完全确定的，在运行期间不会改变这个空间的大小。 Java栈有2种异常类型: StackOverFlowError: 请求的栈深度大于虚拟机所允许的栈深度 OutOfMemoryError: 某些虚拟机栈支持动态扩展，当虚拟机无法申请到足够的内存空间时，就会抛出这个异常。 本地方法栈​ 与Java栈一样，都是描述一个方法执行的内存模型，只是本地方法栈描述的是Native方法的执行。与Java栈一样都会抛出StackOverFlowError和OutOfMemoryError异常。 Java堆​ Java堆是一个被所有线程都共享的区域，几乎所有的对象都需要在这个区域上被分配，所以Java堆也是垃圾收集器管理的主要区域，Java堆也因此被称为 GC堆，由于垃圾收集器的不同，Java堆还可以本细分为很多种情况，这会在以后进行讨论。 ​ Java堆可以处于物理上不连续的内存空间中，只需要逻辑上连续即可。当Java堆无法申请到足够大的空间来分配对象时，会抛出OutOfMemoryError异常。 方法区方法区也是一个线程共享的区域，用于存储已经被JVM加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。在HotSpot虚拟机中，这个区域也别称作`永久代` ，因为HotSpot团队将GC分代收集拓展至了方法区，或者说，用永久代来实现了方法区，这样HotSpot的垃圾收集器就可以像管理Java堆一样管理这块内存了。 ​ 方法区和Java堆一眼，不需要再物理上连续的内存区域，除了可以选择固定大小或者可拓展外，还可以选择是否实现垃圾收集。这块内存可能会抛出OutOfMemoryError异常。 运行时常量池​ 这块区域是方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息，还有一项常量池，用于存放编译期可知的各种符号引用，这部分内容将在类加载之后放入运行时常量池中存放。 ​ 运行时常量池还具有动态性，在运行期间，也可能产生新的常量，如String 的 intern（） 方法。 Java对象对象的创建​ Java对象的创建一般步骤是这样的： ​ （1）当JVM遇到一条new指令时，先会去检查常量池中，是否存在这个类的符号引用，并且检测这个类是否已经被加载、解析和初始化，如果没有将先进行相应类加载过程。 ​ （2）当类加载过程完成之后，需要在Java堆中分配相应大小的内存空间来容纳这个新创建的对象。由于，开发人员可以选择在Java堆使用什么垃圾收集器，而不同的垃圾收集器因为回收算法的不同，回收后的Java堆中的内存可能不是规整的，所以根据内存的规整与否，会采取不同的方法来分配内存。对于规整的内存，可以采用指针碰撞的方法 ，这个方法需要维护一个指针作为分界点的指示器，这个指针的一遍是已经被分配的内存，另一边是未被分配的内存，当需要分配一块内存时，只需要将这个指针向未被分配的那一边移动相应大小。对于内存不规整的情况，可以使用空闲列表的方法，这个方法需要额外维护一个足够大的列表用来记录Java对中哪些内存块是未被使用的，当分配内存时，只需要在这个列表中找到一块足够大的内存空间就可以了。除了如何划分空间之外，内存分配是一个非常频繁的操作，如何保证在多线程环境下保证线程安全也是一个需要考虑的问题，一般有2中解决方法：第一种是CAS+重试的方法，当JVM在进行分配操作时，会用原子的方式去尝试分配，如果分配失败，将会进行重试；另一种是为每个线程分配一个TLAB(Thread Local Allocation Buffer, 本地线程分配缓存)，一个线程会在属于自己线程的TLAB中分配空间。 ​ （3）内存分配完成之后，虚拟机需要将分配到的内存空间都初始化为0值。 ​ （4）接下来，需要对对象进行必要的设置，比如这个对象是哪个类的实例，如何才能找到这个类的元数据信息，对象的哈希，对象的分代年龄信息等，这些都存储在对象头中。 ​ （5）在完成了以上操作后，在JVM角度，一个对象已经产生了，但是一般来说，一个对象还需要按照开发人员的意愿进行初始化，所以JVM执行完new指令是接着会执行方法，对对象进行初始化操作。 对象的内存布局​ 在HotSpot虚拟机中，对象的内存布局配分为3块：对象头、实例数据、对齐填充。 #### 对象头 ​ HotSpot的对象头包括2部分，一部分是记录对象的运行时数据，如哈希码，GC分代年龄，锁状态标志，线程持有的锁，偏向线程ID，偏向时间戳等，这部分数据长度在32bit和64bit的JVM中分别为32bit和64bit；另一部分是类型指针，即对象执行他的类元数据的指针，通过这个指针，可以知道这个对象是哪个类的实例，对于数组对象，这里还有有一个表示数组大小的标志。 实例数据​ 实例数据部分是对象真正存储有效数据的地方，无论是在父类中继承的还是在子类中定义的，都会在这里被记录。这部分的存储顺序会受到JVM的分配策略和在源码中定义的顺序的影响。 对齐填充​ 一个对象实例在内存中所占空间的大小，必须是8字节的整数倍，所以，需要这块空间将一个对象填充。 对象的定位​ 创建对象是为了使用对象，在Java栈的局部变量表中只存储了指向这个对象的引用，却没有规定如何通过这个引用去找到对象，接下来，我会介绍一下2中主流的定位对象的方法：通过使用句柄和直接访问。 使用句柄​ 如果使用句柄的话需要在Java堆中额外划分出一块句柄池，用于存储对象在Java堆中的具体位置信息和对象实例数据，在局部变量表中的引用实际指向的是局部池中对于句柄的位置。 直接访问​ 直接访问，那么reference中存储的就是对象在Java堆中的地址，这种方式需要考虑如何放置访问类型数据的相关信息。 这2种方法各有利弊，对于通过句柄访问，会浪费一次指针定位的开销，但当对象被移动时（如垃圾回收时），只需要修改对象在句柄池中的指针，而不需要修改Java栈中的指针。对于第二种，最大的好处就是速度更快。HotSpot虚拟机采用了第二种方法。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"JVM","slug":"JVM","permalink":"http://yoursite.com/tags/JVM/"}]}]}